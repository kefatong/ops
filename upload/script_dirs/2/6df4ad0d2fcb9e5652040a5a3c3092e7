#!/usr/bin/env python
# coding:utf8

#Author       : kefatong
#Created Date : 2016/01/28
#Version      : 2.0.5

 
import glob
import re
import os
import socket
import fcntl
import struct
#from collections import OrderedDict
#from collections import namedtuple
import pprint
import platform
import dmidecode
import urllib
import urllib2 
import json
import netifaces

 
def diskdevs():
    dev_pattern = ['sd.*','mmcblk*']
    def size(device):
        nr_sectors = open(device+'/size').read().rstrip('\n')
        sect_size = open(device+'/queue/hw_sector_size').read().rstrip('\n')
 
        return round((float(nr_sectors)*float(sect_size))/(1024.0*1024.0*1024.0),2)

    logic_disks = []
    for device in glob.glob('/sys/block/*'):
        for pattern in dev_pattern:
            if re.compile(pattern).match(os.path.basename(device)):
                logic_disks.append({
                    'device_name' : device.split('/')[-1],
                    'device_size' : str(size(device)) + 'GB',
                })



    
    phy_disks = {}
    MegaCli = '/opt/MegaRAID/MegaCli/MegaCli64'
    if os.path.exists(MegaCli):
        os.popen('{0} -CfgDsply -aALL 2>/dev/null > /tmp/megacli.log'.format(MegaCli))
        if os.path.exists('/tmp/megacli.log'):
            with open('/tmp/megacli.log') as f:
                for i in f:

                    if re.search('Slot Number:',i):
                        Slot, = re.findall('Slot Number: (\d)',i)
                        phy_disks[Slot] = {u'磁盘槽位':Slot}

                    if re.search('Media Error Count:',i):
                        phy_disks[Slot][u'逻辑坏道'], = re.findall('Media Error Count: (\d)',i)

                    if re.search('Predictive Failure Count:',i):
                        phy_disks[Slot][u'物理坏道'], = re.findall('Predictive Failure Count: (\d)',i)

                    if re.search('PD Type:',i):
                        phy_disks[Slot][u'磁盘类型'], = re.findall('PD Type: (.*)',i)

                    if re.search('Raw Size:',i):
                        phy_disks[Slot][u'磁盘容量'], = re.findall('Raw Size: (.*)\s\[',i)

                    if re.search('Firmware state:',i):
                        phy_disks[Slot][u'磁盘状态'], = re.findall('Firmware state: (.*)',i)

                    if re.search('Inquiry Data:',i):
                        phy_disks[Slot][u'磁盘序列号'], = re.findall('Inquiry Data: \s*(.*)',i)

            phy_disks = [v for k,v in phy_disks.items()]

    else:
		    phy_disks = []
    disks = {
       'logic_disks': logic_disks,
       'phy_disks': phy_disks,
           }
    return disks


def memory():

    with open('/proc/meminfo') as f:
        meminfo = {}
        for line in f:
            line = line.split(':')
            meminfo[line[0].strip()] = line[1].strip().strip('kB')

    return str(round(int(meminfo['MemTotal']) / 1024.0 / 1024.0)) + 'GB'




def memory_phy():

    memory = []
    dmidecode_memory = dmidecode.memory()

    for k in dmidecode_memory:
        try:
            if dmidecode_memory[k]['data']['Size']:
                memory.append({
                    u'内存容量'   : dmidecode_memory[k]['data']['Size'],
                    u'内存序列号' : dmidecode_memory[k]['data']['Serial Number'],
                    u'主板内存插槽'   : dmidecode_memory[k]['data']['Locator'],
                    u'内存生产商' : dmidecode_memory[k]['data']['Manufacturer'],
                })
        except KeyError:
            pass

    return memory

 
def cpu():

    #cpuinfo=OrderedDict()
    #procinfo=OrderedDict()
    cpuinfo = {}
    procinfo = {}
 
    nprocs = 0
    with open('/proc/cpuinfo') as f:
        for line in f:
            if not line.strip():
                # end of one processor
                cpuinfo['proc%s' % nprocs] = procinfo
                nprocs=nprocs+1
                # Reset
                #procinfo=OrderedDict()
                procinfo = {}
            else:
                if len(line.split(':')) == 2:
                    procinfo[line.split(':')[0].strip()] = line.split(':')[1].strip()
                else:
                    procinfo[line.split(':')[0].strip()] = ''
 
    physics_cores = len(cpuinfo.keys())
    for processor in cpuinfo.keys():
        model = cpuinfo[processor]['model name']
        
    return {'cores':physics_cores,'model':model}


def netdevs():

    interfaces = []
    devs = netifaces.interfaces()

    for dev in devs:
        if dev == 'lo':
            continue
        if netifaces.ifaddresses(dev).has_key(netifaces.AF_INET):
            interfaces.append({
                'dev' :dev,
                'ip'  : netifaces.ifaddresses(dev)[netifaces.AF_INET][0]['addr'],
                'mask': netifaces.ifaddresses(dev)[netifaces.AF_INET][0]['netmask'],
                'mac' : netifaces.ifaddresses(dev)[netifaces.AF_LINK][0]['addr'],
                #'gateway': os.popen('ip route | grep default | cut -d " " -f 3').read().strip('\n')
            })

    return interfaces    



def system():

    #get system info
    _system = {
        'hostname'   :platform.node(),
        'os_version' :'-'.join(platform.dist()),
        'arch'       :platform.machine(),
        'os_type'    :platform.system(),
        'os_release' :platform.release(),
    }

    return _system



def collect():
    dmi = dmidecode.system()
    for k in dmi:
        if dmi[k].has_key('data'):
            if dmi[k]['data'].has_key('Serial Number'):
                dmi = dmi[k]['data']
                break
            
#    print dmi
    system_info = {
        u'主机名'     : system()['hostname'],
        u'系统类型'   : system()['os_type'],
        u'系统版本'   : system()['os_version'],
        u'内核版本'   : system()['os_release'],
        u'系统架构'   : system()['arch'],
        u'CPU数量'    : cpu()['cores'],
        u'CPU型号'    : cpu()['model'],
        u'内存大小'   : memory(),
        u'物理内存'   : memory_phy(),
        u'网络信息'   : netdevs(),
        u'序列号'     : dmi['Serial Number'],
        u'产品名称'   : dmi['Product Name'],
        u'制造商'     : dmi['Manufacturer'],
        u'UUID'       : dmi['UUID'],
        u'磁盘信息'   : diskdevs(),
    }

    system_info = json.dumps(system_info)
    return system_info


def Postdata(url, data):
    user_agent = 'Mozilla/4.0 (compatible; MSIE 5.5; Windows NT)'
    headers = {'Content-Type' : 'application/json'}
    req = urllib2.Request(url, data, headers)
    response = urllib2.urlopen(req)


if __name__ == '__main__':
    url = 'http://10.200.56.122:8989/AssetCMDB/cmdb/ci-impl/create/map'
    data = collect()
    print data
    Postdata(url,data)
